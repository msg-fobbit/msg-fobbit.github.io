<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、实验目的（1）掌握回溯法算法设计思想。 （2）掌握地图填色问题的回溯法解法。 二、实验内容背景知识：    为地图或其他由不同区域组成的图形着色时，相邻国家&#x2F;地区不能使用相同的颜色。 我们可能还想使用尽可能少的不同颜色进行填涂。一些简单的“地图”（例如棋盘）仅需要两种颜色（黑白），但是大多数复杂的地图需要更多颜色。      每张地图包含四个相互连接的国家时，它们至少需要四种颜色。1852年，">
<meta property="og:type" content="article">
<meta property="og:title" content="算法实验报告三-回溯法地图填色">
<meta property="og:url" content="http://example.com/2024/06/02/article1/index.html">
<meta property="og:site_name" content="Msg Fobbit">
<meta property="og:description" content="一、实验目的（1）掌握回溯法算法设计思想。 （2）掌握地图填色问题的回溯法解法。 二、实验内容背景知识：    为地图或其他由不同区域组成的图形着色时，相邻国家&#x2F;地区不能使用相同的颜色。 我们可能还想使用尽可能少的不同颜色进行填涂。一些简单的“地图”（例如棋盘）仅需要两种颜色（黑白），但是大多数复杂的地图需要更多颜色。      每张地图包含四个相互连接的国家时，它们至少需要四种颜色。1852年，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-36-19-image.png">
<meta property="og:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-37-03-image.png">
<meta property="og:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-37-41-image.png">
<meta property="og:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-42-46-image.png">
<meta property="og:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-44-01-image.png">
<meta property="article:published_time" content="2024-06-01T19:53:07.000Z">
<meta property="article:modified_time" content="2024-06-01T20:47:44.416Z">
<meta property="article:author" content="Msg Fobbit">
<meta property="article:tag" content="前端开发, JavaScript, TypeScript, C++, Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-36-19-image.png">

<link rel="canonical" href="http://example.com/2024/06/02/article1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法实验报告三-回溯法地图填色 | Msg Fobbit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Msg Fobbit" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Msg Fobbit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">在校大三学生</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/msg-fobbit" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/02/article1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Msg Fobbit">
      <meta itemprop="description" content="涉猎的主要编程语言为C++、JavaScript、TypeScript、Java等，热爱前端开发。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Msg Fobbit">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法实验报告三-回溯法地图填色
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-06-02 03:53:07 / 修改时间：04:47:44" itemprop="dateCreated datePublished" datetime="2024-06-02T03:53:07+08:00">2024-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a><strong>一、实验目的</strong></h1><p>（1）掌握回溯法算法设计思想。</p>
<p>（2）掌握地图填色问题的回溯法解法。</p>
<h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a><strong>二、实验内容</strong></h1><h2 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h2><pre><code>    为地图或其他由不同区域组成的图形着色时，相邻国家/地区不能使用相同的颜色。 我们可能还想使用尽可能少的不同颜色进行填涂。一些简单的“地图”（例如棋盘）仅需要两种颜色（黑白），但是大多数复杂的地图需要更多颜色。

    每张地图包含四个相互连接的国家时，它们至少需要四种颜色。1852年，植物学专业的学生弗朗西斯·古思里（Francis Guthrie）于1852年首次提出“四色问题”。他观察到四种颜色似乎足以满足他尝试的任何地图填色问题，但他无法找到适用于所有地图的证明。这个问题被称为四色问题。长期以来，数学家无法证明四种颜色就够了，或者无法找到需要四种以上颜色的地图。直到1976年德国数学家沃尔夫冈·哈肯（Wolfgang Haken）（生于1928年）和肯尼斯·阿佩尔（Kenneth Appel，1932年-2013年）使用计算机证明了四色定理，他们将无数种可能的地图缩减为1936种特殊情况，每种情况都由一台计算机进行了总计超过1000个小时的检查。

    他们因此工作获得了美国数学学会富尔克森奖。在1990年，哈肯（Haken）成为伊利诺伊大学（University of Illinois）高级研究中心的成员，他现在是该大学的名誉教授。

    四色定理是第一个使用计算机证明的著名数学定理，此后变得越来越普遍，争议也越来越小。更快的计算机和更高效的算法意味着今天您可以在几个小时内在笔记本电脑上证明四种颜色定理。
</code></pre><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><pre><code>    我们可以将地图转换为平面图，每个地区变成一个节点，相邻地区用边连接，我们要为这个图形的顶点着色，并且两个顶点通过边连接时必须具有不同的颜色。附件是给出的地图数据，请针对三个地图数据尝试分别使用5个（le450_5a），15个（le450_15b），25个（le450_25a）颜色为地图着色。
</code></pre><h1 id="三、实验要求"><a href="#三、实验要求" class="headerlink" title="三、实验要求"></a><strong>三、实验要求</strong></h1><p>1、对下面这个小规模数据，利用四色填色测试算法的正确性；</p>
<p><img src="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-36-19-image.png" title="" alt="" data-align="center"></p>
<p>2、对附件中给定的地图数据填涂；</p>
<p>3、随机产生不同规模的图，分析算法效率与图规模的关系（四色）。</p>
<h1 id="四、实验内容及过程"><a href="#四、实验内容及过程" class="headerlink" title="四、实验内容及过程"></a><strong>四、实验内容及过程</strong></h1><h2 id="4-1、小规模数据，四色填色测试算法的正确性"><a href="#4-1、小规模数据，四色填色测试算法的正确性" class="headerlink" title="4.1、小规模数据，四色填色测试算法的正确性**"></a><strong>4.1</strong>、小规模数据，四色填色测试算法的正确性**</h2><h3 id="4-1-1、问题转化："><a href="#4-1-1、问题转化：" class="headerlink" title="4.1.1、问题转化："></a>4.1.1、问题转化：</h3><pre><code>    地图填色问题描述：将地图转换为平面图，每个地区变成一个节点，相邻地区用边连接，为这个图形的顶点着色，并且两个顶点通过边连接时必须具有不同的颜色。

    转化方式：将小规模数据图的每个地区进行标号，把地图抽象为一个无向图，并把每个地区抽象为这个无向图的顶点，相邻则代表两地区存在连线，相邻顶点颜色不同，边的关系可以用邻接矩阵或邻接表表示。如下图：
</code></pre><p><img src="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-37-03-image.png" title="" alt="" data-align="center"></p>
<p><img title="" src="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-37-41-image.png" alt="" data-align="center"></p>
<h3 id="4-1-2、回溯法介绍："><a href="#4-1-2、回溯法介绍：" class="headerlink" title="4.1.2、回溯法介绍："></a>4.1.2、回溯法介绍：</h3><pre><code>    回溯法简介：回溯法（Backtracking）是一种优先搜索法，可以找出所有（或一部分解）的一般性算法，尤其适用于约束满足问题。回溯法采用试错的思想，尝试分步的去解决一个问题，在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述步骤可能出现两种情况：
</code></pre><ul>
<li><p>找到一个可能存在的正确的答案</p>
</li>
<li><p>在尝试了所有可能的分步方法后宣告该问题没有答案</p>
<pre><code>  **在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算**。在实际应用中，回溯法常常需要结合优化策略，比如可以根据相邻区域的颜色来缩小可选颜色的范围，或者在填色之前先进行一些预处理，减少不必要的搜索等，以提高算法效率。
</code></pre></li>
</ul>
<h3 id="4-1-3、普通（朴素）回溯法实现小数据规模涂色"><a href="#4-1-3、普通（朴素）回溯法实现小数据规模涂色" class="headerlink" title="4.1.3、普通（朴素）回溯法实现小数据规模涂色"></a><strong>4.1.3、普通（朴素）回溯法实现小数据规模涂色</strong></h3><h3 id="4-1-3-1、朴素回溯法实现地图填色思路："><a href="#4-1-3-1、朴素回溯法实现地图填色思路：" class="headerlink" title="4.1.3.1、朴素回溯法实现地图填色思路："></a>4.1.3.1、朴素回溯法实现地图填色思路：</h3><pre><code>    结合4.1.1和4.1.2，我们可以用回溯法解决地图填色问题，w朴素回溯法的基本实现思路为：
</code></pre><ol>
<li><p>选择一个颜色，开始填涂第一个节点；</p>
</li>
<li><p>检查该节点是否满足邻接点不同色，如果满足继续填涂下一节点，若不满足则选择其他颜色；</p>
</li>
<li><p>如果所有颜色都无法满足邻接点不同色的约束条件来实现该节点的填色，则回溯到上一个节点，重新选择颜色进行填涂</p>
</li>
<li><p>重复以上步骤，直到所有节点都填色完成或者到达边界无解</p>
<pre><code> 其具体实现过程可看下图（图中以3色填涂进行思路演示，实验中以4色填涂实现）：
</code></pre></li>
</ol>
<p><img title="" src="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-42-46-image.png" alt="" data-align="center"></p>
<h4 id="4-1-3-2、朴素回溯法伪代码展示："><a href="#4-1-3-2、朴素回溯法伪代码展示：" class="headerlink" title="4.1.3.2、朴素回溯法伪代码展示："></a>4.1.3.2、朴素回溯法伪代码展示：</h4><p><img title="" src="file:///C:/Users/MSG/AppData/Roaming/marktext/images/2024-06-02-04-44-01-image.png" alt="" data-align="center"></p>
<p><strong>4.1.4**</strong>、测试数据结果并验证算法正确性：**</p>
<p><strong>4.1.4.1**</strong>、小规模数据测试：**</p>
<p>测试小规模数据图9_4，测出填色方案总数为480个，耗时0.08259ms。</p>
<p><strong>-**</strong>表4.1.4.1-1 朴素法测试小规模数据结果**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图9_4</th>
<th>填色方案总数</th>
<th>运行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>480</td>
<td>0.08259ms</td>
</tr>
</tbody>
</table>
</div>
<p><strong>4.1.4.2**</strong>、验证算法正确性：**</p>
<p>①、最朴素的验证方式：</p>
<p>每找到一种方案便输出每个节点的着色情况，手动填涂在地图上进行验证。</p>
<p>②、设计一个检验算法正确性的函数：</p>
<p>最朴素的验证方式过于耗时，可以设计一个检验算法正确性函数：</p>
<p>检验填色地图中相邻点的涂色是否相同，如果相同则涂色错误，如果都不同则涂色正确。所以只需要遍历所有边，依次对其相邻点进行颜色检验即可。</p>
<p><strong>-**</strong>图4.1.4.2-1检验算法正确性的函数check（）-**</p>
<p>每求出一种填色方案，就调用一次check函数，经过检验，小规模数据的480个方案的填色结果均正确。</p>
<p>假设有n个节点，m个可选颜色，每个节点都有m种颜色可以选择，所以方案一共mn个。朴素回溯法的算法时间效率过低，相当于在一个深度为n的完全m叉树上进行遍历搜索，<strong>时间复杂度达到O(mn),为指数级别的增长。</strong>我们需要对算法进行优化，实现对附件地图的填色。</p>
<p><strong>4.2**</strong>、优化策略实现对附件中给定的地图数据填涂**</p>
<p><strong>4.2.1**</strong>、可行性剪枝——向前探测**</p>
<p>简单介绍：可行性剪枝是指在回溯法的过程中，通过对问题的约束条件进行分析，判断当前状态是否可行，如果不可行则返回上一层，不再继续搜索。向前探测是一种可行性剪枝技巧，可以预先判断当前状态是否可行。这种思路理论上可以减少搜索空间，提高算法效率。</p>
<p>下面介绍三种与向前探测相关的策略：</p>
<p><strong>4.2.1.1**</strong>、向前探测一步**</p>
<p><strong>①、基本思想：</strong></p>
<p>在给当前节点填涂颜色the_color时，在其未着色的邻接点的可选颜色中删除颜色the_color，以此类推，达到减少搜索空间的目的。向前检验一步，判断是否存在当前节点的邻接点的可涂颜色数为0的情况，如果存在，说明该方案注定失败，提前回溯，否则继续向下搜索。</p>
<p><strong>②、结合具体例子展示：</strong></p>
<p>如下图所示，假设用四色涂色，正在给节点4涂色，若选择黄色，向前检验发现其邻接点3可选颜色为0，提前回溯，测试下一颜色；给节点4选择下一颜色绿色，向前检验后继续搜索，节点3可填涂黄色。</p>
<p><strong>-**</strong>图4.2.1.1-1向前探测一步的具体例子-**</p>
<p><strong>③、伪代码实现：注意对未着色的邻接点的可选颜色数的判断</strong></p>
<p><strong>-**</strong>图4.2.1.1-2向前探测一步的伪代码-**</p>
<p><strong>4.2.1.2**</strong>、向前探测两步**</p>
<p><strong>①、基本思想：</strong></p>
<p>如果向前探测一步不需要提前回溯，且存在当前节点的邻接点the_node的可选颜色数只有一个（the_color）的情况，则探测the_node的邻接点，检查是否存在the_node的邻接点的可选颜色也只剩the_color的情况，如果存在则提前回溯。</p>
<p><strong>②、结合具体例子展示：</strong></p>
<p>如下图所示：假设四色涂色，当前对节点1涂蓝色，向前检验发现其邻接点2可选颜色只剩一个红色，继续探测2的邻接点，发现其邻接点3也只剩红色可选，则此方案注定失败，提前回溯。</p>
<p><strong>-**</strong>图4.2.1.2-1向前探测两步的具体例子-**</p>
<p><strong>③、伪代码实现：</strong></p>
<p>如果向前探测一步成功且存在未涂色邻接点的可选颜色数为1，遍历所有颜色找到该唯一的颜色the_color,继续检验the_node的邻接点，探测成功则继续向下探索，否则提前回溯。</p>
<p><strong>-**</strong>图4.2.1.2-2向前探测两步的伪代码-**</p>
<p><strong>4.2.1.3**</strong>、向前探测一步和约束满足问题（约束传播，CSP）**</p>
<p><strong>①、基本思想：</strong></p>
<p>约束传播的含义是将一个变量的约束内容传播到其他变量，实际上相当于向前探测第二步。向前探测一步没问题，并且存在当前节点的邻接节点的可选颜色数为1的情况，直接填涂这个邻接点，并将受其影响的邻接点的可选颜色删除。以此类推，将可选颜色数为1的节点填涂完，可以减少分支数，达到剪枝的目的。</p>
<p><strong>②、结合具体例子展示：</strong></p>
<p>如下图所示：假设四色涂色，当前对节点1涂蓝色，发现其邻接点2只剩红色可选，那么直接给节点2填涂红色，并将受其影响的节点的可选颜色删除红色，发现此时节点3没有可选颜色，说明此方案注定失败，直接回溯，重新对节点1填涂。</p>
<p><strong>-**</strong>图4.2.1.3-1向前探测一步+约束传播的具体例子分析-**</p>
<p><strong>③、伪代码实现：</strong></p>
<p>向前探测一步后，如果存在未着色且可选颜色为1的节点则将其作为下一次填涂点，如果不存在，则直接进行下一个未着色的节点的填涂。如下图：(此处伪代码只是简单展示，实际实验中结合了向前探测的内容具体实现)</p>
<p><strong>-**</strong>图4.2.1.3-2向前探测一步+约束传播的伪代码-**</p>
<p><strong>4.2.1.4**</strong>、对前面三种策略的数据测试并分析结果：**</p>
<p>运用三种策略对小规模数据9_4地图进行测试，结果求得可填涂方案数与朴素回溯相同，都是480，且运用check（）函数检验填色方案均正确。如下表，三种策略运行时间却比朴素回溯时间略长。尝试用三种策略为附件中的地图填色，结果运行超时。</p>
<p><strong>-**</strong>表4.2.1.4-1向前探测三种策略与朴素回溯测试图9_4的运行时间对比-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图9_4</th>
<th>朴素回溯</th>
<th>向前探测</th>
<th>向前探测+二次探查</th>
<th>向前探测+约束传播</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间/ms</td>
<td>0.08259</td>
<td>0.15543</td>
<td>0.22898</td>
<td>0.12299</td>
</tr>
</tbody>
</table>
</div>
<p>分析原因：向前探测思想是正确的，理论上可以减少分支提高算法效率，但是<strong>对每个点的检测会产生额外的计算</strong>，对简单图的着色运行时间反而会比朴素回溯更慢。无法用这三种颜色对附件中的地图着色，是因为<strong>没有对起始点的选择进行优化</strong>，实际上还是按下标顺序对节点进行填色，且附件中的地图<strong>节点数量多，边数多，对每个结点的邻接点的相关判断相当耗时</strong>，我们需要其他优化策略实现对附件地图的着色。</p>
<p><strong>4.2.2**</strong>、优化搜索顺序——最小剩余量选择（MRV）和度最大选择（DH）**</p>
<p><strong>4.2.2.1**</strong>、介绍MRV和DH原理及伪代码实现**</p>
<p><strong>①、最小剩余量选择（MRV）</strong></p>
<p>在地图填色中，最小剩余量选择是指当前选择节点进行填色时，优先选择分支最少的节点，即优先选择可选颜色数最少的节点。</p>
<p><strong>分析其理论正确性：</strong>可选颜色数最少表示该节点受到的约束最多，更容易搜索完所有可能的颜色，让我们算法更早遇到失败，避免深层回溯，达到提高算法效率的效果。</p>
<p><strong>-**</strong>图4.2.2.1-1 MRV减少深层回溯的示意图-**</p>
<p><strong>②、度最大选择（DH）</strong></p>
<p>度最大选择是指优先选择涉及对其他未赋值节点的约束数量较大的变量，即优先选择未着色邻接点更多的节点进行填色，减少后续搜索的分支数。</p>
<p><strong>分析其理论正确性：</strong>未着色邻接点最多的节点受其他节点的约束最大，先选择该节点进行填涂，可以对未着色邻接点产生更大的约束，减少下层的无效分支。如果没有先填涂该节点而选择周围其他节点，那么约束不足，分支数增加，下层可能会有更多无效分支，方案出错几率大，增加回溯时间。</p>
<p><strong>③、综合考虑MRV和DH</strong></p>
<p>为了更好地优化搜索顺序，我们可以综合应用MRV和DH策略，思路是：首先使用MRV策略，再使用DH策略，即先选出可选颜色最少的节点，若有多个节点可选颜色数都最少，那么优先选择其中度数最大的点。</p>
<p><strong>④、过程演示：</strong></p>
<p>1、首先选择可选颜色数最少且度数最大的点进行涂色。下图中选择节点6给它涂上红色，同时更新影响到的邻接点的可选颜色、可选颜色数和未着色邻接点的数量（即“度”）。</p>
<p>2、接着继续选择当前可选颜色数最少且度数最大的点进行涂色。根据记录表可知，当前可选颜色数最少为 3，可选颜色数为3的节点中度数最大为4，所以我们选择符合条件的节点7进行涂色并更新影响到的邻接点的信息。</p>
<p>3、以此类推，直到把所有节点都填完色。</p>
<p><strong>-**</strong>图4.2.2.1-2 MRV和DH策略填色步骤示意图-**</p>
<p><strong>⑤、伪代码展示：</strong></p>
<p>包括一个选出符合MRV_DH策略的节点的函数find_min_colors和采用MRV_DH策略进行回溯法填色的函数。</p>
<p><strong>选出符合MRV_DH策略的节点的函数：</strong>遍历每个节点比较他们的可选颜色数，如果可选颜色数都为最少，则比较未着色邻接点数量，直到找到可选颜色数最少且未着色邻接点数量最多的节点。</p>
<p><strong>-**</strong>图4.2.2.1-3 选出符合MRV_DH策略的节点的函数伪代码-**</p>
<p><strong>使用MRV和DH策略的回溯法函数：</strong>调用函数find_min_colors选出当前填色节点进行填色，填色过程中要更新受影响节点的相关信息。如果遇到失败是要回溯则恢复被处理的节点的相关信息。</p>
<p><strong>-**</strong>图4.2.2.1-4 使用MRV和DH策略的回溯法函数伪代码-**</p>
<p><strong>4.2.2.2**</strong>、数据测试及结果分析**</p>
<p>对小规模数据和附件给的地图数据填色，除了测试4.2.2中我们重点介绍的MRV和DH策略，我还结合了4.2.1中的向前探测策略。如下图所示：结合了MRV和DH策略之后的向前探测策略也完成了对附件地图的填色。</p>
<p><strong>-**</strong>表4.2.2.2-1 与MRV和DH相关的策略测试地图(时间单位：ms)-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>9_4</th>
<th>450_5</th>
<th>450_15</th>
<th>450_25</th>
</tr>
</thead>
<tbody>
<tr>
<td>MRV_DH</td>
<td>0.14782</td>
<td>23048.0</td>
<td>22987.3</td>
<td>16803.7</td>
</tr>
<tr>
<td>MRV_DH+向前探测</td>
<td>0.13376</td>
<td>22187.9</td>
<td>22957.6</td>
<td>15821.3</td>
</tr>
<tr>
<td>MRV_DH+二次探查</td>
<td>0.26154</td>
<td>23216.3</td>
<td>23678.1</td>
<td>16824.9</td>
</tr>
<tr>
<td>MRV_DH+向前探测+约束传播</td>
<td>0.14772</td>
<td>9245.2</td>
<td>14792.2</td>
<td>13884.6</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注：A、</strong>9_4方案总数480，450_5方案总数3840，450_15和450_25方案总数太多，这里的运行时间为求解<strong>一亿个方案所需时间</strong>。</p>
<p><strong>B**</strong>、450_15的地图染色起始点的选择非常重要。<strong>与另外三个地图不同，如果450_15的地图选择的第一个点是符合MRV和DH策略的，那么运行会超时。上表中的450_15的数据为</strong>选择节点338作为起始点**测得的数据。（“五、实验结果及分析”中会对这一现象进行详细解释）</p>
<p><strong>分析：</strong>在4.2.1中无法实现对附加地图着色的向前探测策略结合了MRV和DH策略之后成功实现对三个稠密图的填色。说明优先搜索顺序的剪枝策略可以很大程度上提高回溯法效率，起始点的选择对求解方案的时间有很大影响。从这里也可以看出，向前探测两次的优化效果并不理想，甚至运行时间比向前探测一次长，原因可能是向前探测第二次需要<strong>多次检测判断消耗了额外的运行时间</strong>。对于大规模数据，效果最好的方法是<strong><u><span lang="EN-US">MRV_DH+</span></u>**</strong><u><span>向前探测<span lang="EN-US">+</span>约束传播。<span lang="EN-US">&lt;/span&gt;</span></u>**</p>
<p><strong>4.2.3**</strong>、排除等效冗余——等效替换颜色（颜色轮寻）**</p>
<p>从小规模数据中可以看出，很多填色方案本质上是一样的，只是相同区域上填涂的颜色不一致，因此可以用等效替换的思想进行优化。</p>
<p><strong>-**</strong>图4.2.3-1 地图填色中的等效方案展示-**</p>
<p><strong>①、基本思想：</strong></p>
<p>搜索到一个可填色方案后，可用等效替换的方式将其余的颜色轮换，得到多个等效方案，<strong>求解多个方案</strong>时可以大大降低时间复杂度。</p>
<p><strong>②、结合具体例子展示：</strong></p>
<p>采用朴素回溯法的示意图（假设可填涂颜色为3）：</p>
<p><strong>-**</strong>图4.2.3-2 颜色轮寻实现过程-**</p>
<p>在上图中，给第一个节点填色时，有三种等效颜色，所以可以只选绿色，找到可行方案后乘以3即可，以此类推。</p>
<p><strong>③、伪代码实现：</strong></p>
<p>实验过程中<strong>将颜色轮询和向前探测、MRV和DH策略结合</strong>进行测试。颜色按照序号有序填涂，可以设置一个变量used记录当前使用过的颜色下标，正在填涂的颜色序号大于used时，说明未使用过，否则表示已经使用过。对于未使用过的颜色有可替代方案，加入方案总数results。</p>
<p><strong>-**</strong>图4.2.3-3 颜色轮寻核心代码展示-**</p>
<p><strong>④、数据测试及分析：</strong></p>
<p>对四张地图进行填色，并与4.2.2中效果最好的方法“MRV_DH+向前探测+约束传播”进行对比，结果见下表：</p>
<p><strong>-**</strong>表4.2.3-1 加入颜色轮寻策略后的测试结果（时间单位：ms）-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>9_4</th>
<th>450_5</th>
<th>450_15</th>
<th>450_25</th>
</tr>
</thead>
<tbody>
<tr>
<td>MRV_DH+向前探测+约束传播</td>
<td>0.14772</td>
<td>9245.2</td>
<td>14792.2</td>
<td>13884.6</td>
</tr>
<tr>
<td>MRV_DH+向前探测+颜色轮寻</td>
<td>0.00745</td>
<td>116.9</td>
<td>2465.4</td>
<td>1679.6</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注：A、</strong>9_4方案总数480，450_5方案总数3840，450_15和450_25方案总数太多，这里的运行时间为求解<strong>大于1亿个方案所需时间</strong>。</p>
<p><strong>B**</strong>、450_15的地图选择节点338作为起始点**（同表4.2.2.2-1）</p>
<p><strong>分析：</strong>根据表中数据可知，颜色轮寻剪枝效果显著，对四种地图求解多个填色方案的速度比之前任何策略都快，极大地减少了程序运行时间。但是值得注意的是，这种方法并<strong>不能获得所有方案的具体填色方案。</strong></p>
<p><strong>4.3**</strong>、随机生成不同规模的图，分析算法效率与图规模的关系**</p>
<p><strong>4.3.1**</strong>、随机生成可以用四色填涂的地图**</p>
<p><strong>4.3.1.1**</strong>、一开始的错误思路：**</p>
<p>随机生成不同规模的图很简单，利用随机生成数，生成一定范围内的点对，用哈希函数去重，点对生成边，将相关信息保存在txt文件中。</p>
<p>在实验过程中发现，这样生成的图不一定能够用四色实现填涂全部节点,为了更好地测试算法效率与图规模的关系，需要改进随机生成地图的算法，生成可以用四色填涂地地图。</p>
<p><strong>4.3.1.2**</strong>、如何随机生成可以用四色填涂的地图：**</p>
<p><strong>①、改进思路及实现原理：</strong></p>
<p><strong>Step1**</strong>：<strong>设地图节点总数为n，边数为m，可选颜色为4，将n个节点分割成数量相等的四块，假设每块的节点填涂一样的颜色，</strong>四块颜色不同**，如下图所示：</p>
<p><strong>-**</strong>图4.3.1.2-1 随机生成可用四色填涂的地图第一步-**</p>
<p><strong>Step2**</strong>：<strong>不同块的节点之间随机生成边，即不同颜色的节点之间相互连线，由于相同颜色的节点都在同一块中，</strong>边产生于不同块之间，符合邻接点不同色，**所以这样生成的地图一定能用四色填涂。</p>
<p><strong>-**</strong>图4.3.1.2-2 随机生成可用四色填涂的地图第二步-**</p>
<p><strong>Step3**</strong>：**每个节点去掉颜色和块边框，保留连线，此时的无向图符合四色填涂要求。</p>
<p><strong>-**</strong>图4.3.1.2-3 随机生成可用四色填涂的地图第三步-**</p>
<p><strong>②、具体实现：</strong></p>
<p>该函数可以生成指定节点数和边数的地图，并且一次生成五张符合输入条件的地图。生成思路：利用随机数随机生成两个节点u和v，判断u和v是否在同一个块中（<strong>节点按照序号分成数量相等的四块</strong>）,如果在同一块中则重新生成直到两节点不同块，此时u和v的连线构成一条边，将边信息转化为字符串表示，判断是否已有重复边，如果没有重复则加入哈希表便于后续判断，并且存入文件。</p>
<p><strong>-**</strong>图4.3.1.2-4 随机生成可用四色填涂的地图代码展示-**</p>
<p><strong>4.3.2**</strong>、测试算法效率**</p>
<p>从三个方面测试算法效率：<strong>节点数、平均度数和可选颜色数</strong>。</p>
<p><strong>关于算法运行效率的测试均采用“MRV_DH+向前探测+约束传播”方法。</strong>在测试之前了解一些理论：</p>
<p><strong>简单平面图：</strong>图论中平面图是指可以画在平面上并且不同边互不交叠的图。下文简称为“<strong>平面图”。</strong></p>
<p><strong>平均度数：</strong>图中每个顶点的度数的平均值。<strong>公式：（2×边数）/节点数</strong></p>
<p><strong>欧拉公式证明平面图的平均度数小于6：</strong></p>
<p>设一个平面图中顶点数为V，边数为E，面数为F，则有：</p>
<pre><code>             **公式（1）**
</code></pre><p>若图G是连通的简单平面图，那么每个面都由至少3个边围成，每个边仅接触两个面，因此有</p>
<pre><code>               **公式（2）**
</code></pre><p>将公式（2）代入公式（1）,可得：</p>
<pre><code>              **公式（3）**
</code></pre><p>设<strong>平均度数为AVG_D</strong>,那么有：</p>
<pre><code>            **公式（4）**
</code></pre><p>将公式（3）代入公式（4）,可得：</p>
<pre><code>          **公式（5）**
</code></pre><p>由此可知<strong>平面图平均度数是严格小于6的。</strong>地图填色问题通常基于简单平面图的模型展开，<strong>所以在后面的测试中生成的随机地图的平均度数不大于6。</strong></p>
<p><strong>4.3.2.1**</strong>、随机生成地图测试节点数对算法效率的影响**</p>
<p><strong>①、较小规模下测试，节点数100-1000</strong></p>
<p>固定平均度数为4，可选颜色数为4，节点数为100-1000，记录<strong>求解一个方案的平均运行时间</strong>。测试结果如下：</p>
<p><strong>-**</strong>表4.3.2.1-1 算法效率随节点数变化情况（100-1000）-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>节点数</th>
<th>100</th>
<th>200</th>
<th>300</th>
<th>400</th>
<th>500</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时间/μs</td>
<td>0.3</td>
<td>0.8</td>
<td>1.6</td>
<td>2.6</td>
<td>3.7</td>
</tr>
<tr>
<td>节点数</td>
<td>600</td>
<td>700</td>
<td>800</td>
<td>900</td>
<td>1000</td>
</tr>
<tr>
<td>运行时间/μs</td>
<td>4.8</td>
<td>5.9</td>
<td>7</td>
<td>8.7</td>
<td>10.4</td>
</tr>
</tbody>
</table>
</div>
<p><strong>-**</strong>图4.3.2.1-1 运行时间随节点数变化曲线图1（红色虚线为线性趋势线）-**</p>
<p><strong>分析：</strong>从数据记录表和曲线图可知，<strong>当平均度数一定时，随着节点数的增加，求解一个可填涂方案所需时间也随之增加</strong>。对曲线图进行拟合，发现其与线性趋势线接近。在对朴素回溯法的分析中，我们分析其时间复杂度达到了指数型。<strong>在</strong></p>
<p><strong>顶点数为100-1000，平均度数为4的情况下，使用了MRV_DH+向前探测+约束传播方法的回溯法的时间复杂度近乎于达到了线性</strong>。</p>
<p><strong>②、较大规模测试，节点数2000-10000</strong></p>
<p>固定平均度数为4，可选颜色数为4，节点数为2000-10000，记录<strong>求解一个方案的平均运行时间并计算时间的对数值</strong>。测试结果如下：</p>
<p><strong>-**</strong>表4.3.2.1-2 算法效率随节点数变化情况（2000-10000）-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>节点数</th>
<th>2000</th>
<th>3000</th>
<th>4000</th>
<th>5000</th>
<th>6000</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时间/ms</td>
<td>4.23</td>
<td>9.49</td>
<td>23.46</td>
<td>43.86</td>
<td>89.49</td>
</tr>
<tr>
<td>运行时间的对数</td>
<td>0.625909</td>
<td>0.977458</td>
<td>1.370343</td>
<td>1.642034</td>
<td>1.951760</td>
</tr>
<tr>
<td>节点数</td>
<td>7000</td>
<td>8000</td>
<td>9000</td>
<td>1000</td>
<td></td>
</tr>
<tr>
<td>运行时间/ms</td>
<td>163.81</td>
<td>267.10</td>
<td>399.02</td>
<td>745.26</td>
<td></td>
</tr>
<tr>
<td>运行时间的对数</td>
<td>2.214351</td>
<td>2.426677</td>
<td>2.600989</td>
<td>2.872308</td>
</tr>
</tbody>
</table>
</div>
<p><strong>-**</strong>图4.3.2.1-2 运行时间随节点数变化曲线图2-**</p>
<p><strong>分析：</strong>从数据记录表和曲线图可知，与小数据规模相同，当平均度数一定时，随着节点数的增加，求解一个可填涂方案所需时间也随之增加。与小数据规模不同的是，在节点数为2000-10000的情况下，随着节点数的增大，运行时间的增长是非线性的，开始时增速较缓，随着点的规模变大，运行时间增速越来越快。推测此时算法复杂度可能达到O(n²)，为了验证此推测，对运行时间取对数进一步分析。</p>
<p><strong>-**</strong>图4.3.2.1-3 运行时间的对数值随节点数变化曲线图（红色曲线为线性趋势线）-**</p>
<p><strong>分析：</strong>根据运行时间的对数值随节点数变化的曲线图可知，在节点数范围为2000-10000的情况下，随着节点数的增加，求解第一个方案所需的时间的对数值呈现<strong>线性关系。</strong>可以推测用MRV和DH、向前探测和约束传播策略优化后的回溯法的时间复杂接近O(n²)，剪枝效果显著，极大地降低了时间复杂度。</p>
<p><strong>4.3.2.2**</strong>、随机生成地图测试平均度数对算法效率的影响**</p>
<p>固定节点数为5000，可选颜色数为4，平均度数为1-5，测试<strong>求解10000个方案所需的平均时间</strong>。测试结果如下：</p>
<p><strong>-**</strong>表4.3.2.2-1运行时间随平均度数变化的情况-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平均度数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时间/ms</td>
<td>98.7694</td>
<td>101.2725</td>
<td>103.4758</td>
<td>104.356</td>
<td>89.3511</td>
</tr>
</tbody>
</table>
</div>
<p><strong>-**</strong>图4.3.2.2-1 运行时间随节平均度数变化曲线图-**</p>
<p><strong>分析：</strong>根据数据记录表和曲线图可知，平均度数为1-4时求解10000个方案所需时间随着平均度数的增加而有所增加，而平均度数由4到5的运行时间反而减少。但总体而言，<strong>5**</strong>种平均度数情况下的运行时间都很接近**。</p>
<p><strong>分析可能原因:</strong></p>
<p>①、<strong>随机生成的地图较均匀，填色过程几乎不需要太多的回溯</strong>，且平均度数较低，地图中不存在难以跳出的“迷宫”，均很快找出方案，平均度数对运行时间的影响不大。<strong>验证：</strong>在实验过程中记录求解10000个方案所需的回溯次数，发现在五个不同平均度数的情况下回溯次数皆在18000次左右。</p>
<p>②、平均度数为5的地图，相对于平均度数1-4的地图，其每个节点的邻接点数量增加，可能导致搜索树的深度（最坏情况下，搜索树深度等于未着色的节点数）减少，从而减少搜索空间和搜索时间；并且节点的分支因子相对较大，搜索树的形状可能更平衡，节点的约束力更大，<strong>运用了剪枝策略后剪枝效果更好</strong>，加快了求解方案速度。而在平均度数较低的情况下，搜索树的形状可能不太平衡，剪枝策略的效果不好，导致所需运行时间相对较长。</p>
<p><strong>4.3.2.3**</strong>、在小规模数据上测试可选颜色数对算法效率的影响**</p>
<p>利用MRV_DH+向前探测+约束传播测试图9_4,可选颜色数为4、5、6、7，测试其可填涂总方案数、回溯次数和运行时间。测试结果如下：</p>
<p><strong>-**</strong>表4.3.2.3-1 算法效率随可填涂颜色数变化情况-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图9_4，运行时间随可填涂颜色数变化情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>颜色数</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>运行时间/ms</td>
<td>0.1954</td>
<td>4.1744</td>
<td>53.8028</td>
<td>311.579</td>
</tr>
<tr>
<td>方案总数</td>
<td>480</td>
<td>21600</td>
<td>293760</td>
<td>2184000</td>
</tr>
<tr>
<td>回溯次数</td>
<td>1337</td>
<td>36446</td>
<td>417277</td>
<td>2841560</td>
</tr>
<tr>
<td>时间/方案总数</td>
<td>0.000407083</td>
<td>0.000193259</td>
<td>0.000183152</td>
<td>0.000142664</td>
</tr>
</tbody>
</table>
</div>
<p><strong>分析：</strong>从表中可知，随着可填涂颜色数的增加，可填涂方案总数、回溯次数、运行总时间也增加，这是可以预见的。<strong>但是求解每个方案所需时间（即总时间/方案总数）减少</strong>，这是因为<strong>当可选颜色数增加时，邻接点不同色的约束条件更容易满足</strong>，遇到失败后回溯浪费的时间减少，求解一个方案所需的时间也减少。</p>
<p><strong>五、实验结果及分析</strong></p>
<p><strong>5.1**</strong>、运用各种策略对四种地图着色的结果展示及总分析：**</p>
<p>此次实验总共测试了九种回溯法，其中<strong>MRV**</strong>和DH策略对起始点的选择优化是决定性的一步**，因为在此之前只考虑了向前探测策略而无法实现对大规模地图的着色。下表为综合数据：</p>
<p><strong>-**</strong>表5.1-1 各种策略对地图着色的数据 -**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方法名称</th>
<th>9_4</th>
<th>450_5</th>
<th>450_15</th>
<th>450_25</th>
</tr>
</thead>
<tbody>
<tr>
<td>测试方法\填色方案总数</td>
<td></td>
<td>480</td>
<td>3840</td>
<td>1亿+</td>
<td>1亿+</td>
</tr>
<tr>
<td>1</td>
<td>朴素回溯</td>
<td>0.08259</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>2</td>
<td>向前探测</td>
<td>0.15543</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>3</td>
<td>向前探测+二次探查</td>
<td>0.22898</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>4</td>
<td>向前探测+约束传播</td>
<td>0.12299</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>5</td>
<td>MRV_DH</td>
<td>0.14782</td>
<td>23048.0</td>
<td>22987.3</td>
<td>16803.7</td>
</tr>
<tr>
<td>6</td>
<td>MRV_DH+向前探测</td>
<td>0.13376</td>
<td>22187.9</td>
<td>22957.6</td>
<td>15821.3</td>
</tr>
<tr>
<td>7</td>
<td>MRV_DH+二次探查</td>
<td>0.26154</td>
<td>23216.3</td>
<td>23678.1</td>
<td>16824.9</td>
</tr>
<tr>
<td>8</td>
<td>MRV_DH+向前探测+约束传播</td>
<td>0.14772</td>
<td>9245.2</td>
<td>14792.2</td>
<td>13884.6</td>
</tr>
<tr>
<td>9</td>
<td>MRV_DH+向前探测+颜色轮寻</td>
<td>0.00745</td>
<td>116.9</td>
<td>2465.4</td>
<td>1679.6</td>
</tr>
</tbody>
</table>
</div>
<p>对于大规模数据来说，最优秀的优化策略为“MRV_DH+向前探测+约束传播”和“MRV_DH+向前探测+颜色轮寻”。其中，<strong>“MRV_DH+向前探测+约束传播”</strong>可以在<strong>较快</strong>时间内求出<strong>多种方案及其具体填色结果</strong>；而<em>“MRV_DH+向前探测+颜色轮寻”</em>可以在<strong>最快</strong>时间内求解出多种方案，但是<strong>无法显示每种方案具体填色结果</strong>。</p>
<p>对于9_4整个小规模数据图，求解所有方案最快的是朴素回溯和“MRV_DH+向前探测+颜色轮寻”，这是因为<strong>朴素回溯不需要对每个节点进行深度探测或约束，在数据规模较小且地图较简单时速度反而比优化后的快</strong>。“MRV_DH+向前探测+颜色轮寻”根据其等效替代的思想，剪枝效果显著，能够在最快时间内找出所有解。</p>
<p>在实际应用时可以根据待填色地图特点和填色要求选择合适的策略。</p>
<p><strong>5.2**</strong>、对附件中的图450_15进一步分析：**</p>
<p>450_15是个非常复杂的地图，内部很稠密，在使用MRV和DH策略选择起始点时，运行超时。多次运行调试发现，其内部可能存在一个“迷宫”,在其中回溯次数特别多，且很难跳出来求解可填涂方案。因此为了实现对450_15地图的着色，我改变了起始点的选择。经过多次测试发现，以1、338和432等点作为起始点可以成功填色。前文中对450_15的数据记录都是以338为起始点实现的。</p>
<p>实验过程中还发现，<strong>选取不同的起始点对运行时间的影响很大，选取合适的起始点是提高填色效率的关键。</strong></p>
<p><strong>-**</strong>表5.2-1 不同起始点对运行时间的影响(采用“MRV_DH+向前探测+约束传播”方法)-**</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图450_15的起始点</th>
<th>1</th>
<th>338</th>
<th>432</th>
</tr>
</thead>
<tbody>
<tr>
<td>求解一个填色方案所需时间/ms</td>
<td>125.231</td>
<td>64.4489</td>
<td>102.64</td>
</tr>
</tbody>
</table>
</div>
<p><strong>5.3**</strong>、算法效率测试结果及分析：**</p>
<p>各种数据及具体分析已在“4.3”中详细展示，这里总结几点内容：</p>
<p>①、朴素回溯法的算法时间复杂度在最坏情况下是指数型，经过“MRV_DH+向前探测+约束传播”方法优化后，对于小规模数据(100-1000)，节点数对运行时间的影响是线性的，对于大规模数据（2000-10000），节点数对运行时间的影响趋势接近二次曲线。</p>
<p>②、平均度数对算法效率的影响是非线性的，需要综合各种因素考虑其对算法复杂度的影响。</p>
<p>③、可选颜色数也会对算法效率造成影响，总的来说可填涂颜色数增加，求解所有方案需要的总时间增加，但是求解一个方案所需的时间可能减少。</p>
<p>④、起始点的选择是求解填色方案的关键。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/31/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">1.</span> <span class="nav-text">一、实验目的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">二、实验内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">背景知识：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">问题描述：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="nav-number">3.</span> <span class="nav-text">三、实验要求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E5%8F%8A%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">四、实验内容及过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E3%80%81%E5%B0%8F%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9B%9B%E8%89%B2%E5%A1%AB%E8%89%B2%E6%B5%8B%E8%AF%95%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、小规模数据，四色填色测试算法的正确性**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1%E3%80%81%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96%EF%BC%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1、问题转化：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2%E3%80%81%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2、回溯法介绍：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3%E3%80%81%E6%99%AE%E9%80%9A%EF%BC%88%E6%9C%B4%E7%B4%A0%EF%BC%89%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E6%B6%82%E8%89%B2"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3、普通（朴素）回溯法实现小数据规模涂色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-1%E3%80%81%E6%9C%B4%E7%B4%A0%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9B%BE%E5%A1%AB%E8%89%B2%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.3.1、朴素回溯法实现地图填色思路：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-2%E3%80%81%E6%9C%B4%E7%B4%A0%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%EF%BC%9A"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">4.1.3.2、朴素回溯法伪代码展示：</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Msg Fobbit"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Msg Fobbit</p>
  <div class="site-description" itemprop="description">涉猎的主要编程语言为C++、JavaScript、TypeScript、Java等，热爱前端开发。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Msg Fobbit</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '',
      clientSecret: '',
      repo        : 'msg-fobbit.github.io',
      owner       : 'msg-fobbit',
      admin       : ['msg-fobbit'],
      id          : '2ccb884109101657f33d8f97f43f26e6',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
